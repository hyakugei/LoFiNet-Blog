<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Simple Sprite Animator Documentation - LofFiNet</title><meta name="description" content="Animation Controller Documentation This guide explains how to use the Animation Controller system in code. The Animation Controller provides a lightweight, code-driven sprite animation system that works with the Animation DSL. The Animation Controller system consists of: Idle: 20, 20, 20, 20, _loop Run: 5,&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://dev.lofinet.org/simple-sprite-animator-documentation.html"><link rel="alternate" type="application/atom+xml" href="https://dev.lofinet.org/feed.xml" title="LofFiNet - RSS"><link rel="alternate" type="application/json" href="https://dev.lofinet.org/feed.json" title="LofFiNet - JSON"><meta property="og:title" content="Simple Sprite Animator Documentation"><meta property="og:site_name" content="LofFiNet"><meta property="og:description" content="Animation Controller Documentation This guide explains how to use the Animation Controller system in code. The Animation Controller provides a lightweight, code-driven sprite animation system that works with the Animation DSL. The Animation Controller system consists of: Idle: 20, 20, 20, 20, _loop Run: 5,&hellip;"><meta property="og:url" content="https://dev.lofinet.org/simple-sprite-animator-documentation.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://dev.lofinet.org/assets/css/style.css?v=b09e72b2ca1a38c969d44da51bb22509"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://dev.lofinet.org/simple-sprite-animator-documentation.html"},"headline":"Simple Sprite Animator Documentation","datePublished":"2025-11-24T09:27-05:00","dateModified":"2025-11-24T09:27-05:00","description":"Animation Controller Documentation This guide explains how to use the Animation Controller system in code. The Animation Controller provides a lightweight, code-driven sprite animation system that works with the Animation DSL. The Animation Controller system consists of: Idle: 20, 20, 20, 20, _loop Run: 5,&hellip;","author":{"@type":"Person","name":"Jos","url":"https://dev.lofinet.org/authors/jos/"},"publisher":{"@type":"Organization","name":"Jos"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="page-template"><header class="top js-header"><a class="logo" href="https://dev.lofinet.org/">LofFiNet</a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://dev.lofinet.org/todo.html" target="_self">Todo</a></li></ul></nav></header><main class="page"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>Simple Sprite Animator Documentation</h1></div></header></div><div class="entry-wrapper content__entry"><h1 id="animation-controller-documentation">Animation Controller Documentation</h1><p>This guide explains how to use the Animation Controller system in code. The Animation Controller provides a lightweight, code-driven sprite animation system that works with the Animation DSL.</p><h2 id="overview">Overview</h2><p>The Animation Controller system consists of:</p><ul><li><strong><code>AnimationController</code></strong> - Base class that manages animation state and timing</li><li><strong><code>SpriteResolverAnimationController</code></strong> - Ready-to-use implementation for Unity’s SpriteResolver</li><li><strong><code>DSLAsset</code></strong> - ScriptableObject that stores your animation definitions</li><li><strong>Animation DSL</strong> - Text-based format for defining animation states (see <a href="./DSL_DOCUMENTATION.md">DSL_DOCUMENTATION.md</a>)</li></ul><h2 id="quick-start">Quick Start</h2><h3 id="1-create-a-dsl-asset">1. Create a DSL Asset</h3><ol><li>Right-click in your Project window</li><li>Select <strong>Create &gt; PhantomCompass &gt; DSLAsset</strong></li><li>Name it (e.g., “Main Animation Data”)</li><li>Open the asset and write your animation definitions in the DSL text area:</li></ol><pre><code>Idle: 20, 20, 20, 20, _loop
Run: 5, 5, 5, 5, _loop
Jump: 5, 5, 5, _wait
Attack: 8, 8, 8, Idle
</code></pre><h3 id="2-add-animation-controller-to-your-gameobject">2. Add Animation Controller to Your GameObject</h3><p>Add a <code>SpriteResolverAnimationController</code> component to your GameObject (or a child GameObject). This component:</p><ul><li>Manages animation state</li><li>Updates sprite visuals automatically</li><li>Works with Unity’s SpriteResolver component</li></ul><p><strong>Required Setup:</strong></p><ul><li>The GameObject (or a child) must have a <code>SpriteResolver</code> component</li><li>Assign your DSL Asset to the <code>_dslAsset</code> field</li><li>Optionally set a <code>Default State</code> (e.g., “Idle”)</li></ul><h3 id="3-basic-usage-in-code">3. Basic Usage in Code</h3><pre><code class="language-csharp">using PhantomCompass.Animation;

public class MyCharacter : MonoBehaviour
{
    private SpriteResolverAnimationController animController;
    
    void Start()
    {
        animController = GetComponent&lt;SpriteResolverAnimationController&gt;();
    }
    
    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Space))
        {
            // Change animation state
            animController.SetState(&quot;Jump&quot;);
        }
    }
}
</code></pre><h2 id="core-concepts">Core Concepts</h2><h3 id="animation-states">Animation States</h3><p>An animation state is a named sequence of frames defined in your DSL. Each state has:</p><ul><li>A name (e.g., “Idle”, “Run”, “Attack”)</li><li>A list of frames with durations</li><li>End behavior (<code>_loop</code>, <code>_wait</code>, <code>_pingpong</code>, or a state transition)</li></ul><h3 id="frame-updates">Frame Updates</h3><p>The animation system uses a <strong>tick-based</strong> update model. You must call <code>Tick()</code> on the animation controller each frame (typically from a fixed-rate system).</p><p><strong>Important:</strong> The animation controller does NOT automatically update in <code>Update()</code>. You must call <code>Tick()</code> manually, usually from:</p><ul><li><code>Entity.Tick()</code> (for entity-driven animations)</li><li>A custom fixed-rate system</li><li>Or enable <code>_autoTickInUpdate</code> for standalone animations</li></ul><h3 id="sprite-updates">Sprite Updates</h3><p>When a new frame is reached, the <code>_isNewFrame</code> flag is set. Subclasses like <code>SpriteResolverAnimationController</code> check this flag in <code>LateUpdate()</code> and update sprite visuals accordingly.</p><h2 id="api-reference">API Reference</h2><h3 id="animationcontroller">AnimationController</h3><h4 id="properties">Properties</h4><p><strong><code>CurrentState</code></strong> (read-only)</p><ul><li>Returns the name of the currently playing animation state</li><li>Returns <code>null</code> or empty string if no state is set</li></ul><p><strong><code>DefaultState</code></strong></p><ul><li>The state to play when no state is set</li><li>Set this in the inspector or via code</li></ul><p><strong><code>DurationMultiplier</code></strong></p><ul><li>Multiplies all frame durations (1.0 = normal speed, 2.0 = half speed, 0.5 = double speed)</li><li>Minimum value: 0.001</li><li>Useful for slow-motion effects or speeding up animations</li></ul><h4 id="methods">Methods</h4><p><strong><code>SetState(string stateName)</code></strong></p><ul><li>Changes the animation to the specified state</li><li>Resets to frame 0 of that state</li><li>State name is case-sensitive and must match a state in your DSL</li></ul><p><strong><code>Tick()</code></strong></p><ul><li>Advances the animation by one frame</li><li>Should be called every fixed update tick (typically 60 times per second)</li><li>Processes frame timing, events, and state transitions</li><li>Sets <code>_isNewFrame</code> flag when a new frame is reached</li></ul><p><strong><code>HasState(string stateName)</code></strong></p><ul><li>Checks if a state exists (currently returns false - may be implemented later)</li></ul><h4 id="events">Events</h4><p><strong><code>AnimationEvent</code></strong> (<code>Action&lt;string&gt;</code>)</p><ul><li>Fired when an animation event occurs</li><li>Event names come from your DSL (e.g., <code>&quot;swingSound&quot;</code>, <code>&quot;hitFrame&quot;</code>, <code>&quot;_loop&quot;</code>)</li><li>Subscribe to handle sound effects, hitboxes, visual effects, etc.</li></ul><h3 id="protected-members-for-subclasses">Protected Members (for Subclasses)</h3><p><strong><code>_currentFrameData</code></strong> (<code>FrameData</code>)</p><ul><li>Contains data for the current frame (frameIndex, duration, events)</li></ul><p><strong><code>_currentStateData</code></strong> (<code>StateData</code>)</p><ul><li>Contains data for the current state (state name, sprite category alias, frames)</li></ul><p><strong><code>_isNewFrame</code></strong> (bool)</p><ul><li>Set to <code>true</code> when a new frame is reached</li><li>Subclasses should check this in <code>LateUpdate()</code> and call <code>ClearNewFrameFlag()</code> after updating visuals</li></ul><p><strong><code>ClearNewFrameFlag()</code></strong></p><ul><li>Clears the <code>_isNewFrame</code> flag</li><li>Call this after updating sprite visuals</li></ul><h2 id="common-usage-patterns">Common Usage Patterns</h2><h3 id="pattern-1-entity-driven-animation">Pattern 1: Entity-Driven Animation</h3><p>For animations tied to game entities (players, NPCs, enemies):</p><pre><code class="language-csharp">public class Entity : MonoBehaviour
{
    private SpriteResolverAnimationController animController;
    
    void Start()
    {
        animController = GetComponent&lt;SpriteResolverAnimationController&gt;();
        
        // Subscribe to animation events
        animController.AnimationEvent += OnAnimationEvent;
    }
    
    // Called by game loop at fixed rate (60hz)
    public void Tick()
    {
        // Update animation
        animController.Tick();
        
        // ... other entity logic ...
    }
    
    public void PlayAnimation(string stateName)
    {
        animController.SetState(stateName);
    }
    
    private void OnAnimationEvent(string eventName)
    {
        // Handle animation events
        if (eventName == &quot;swingSound&quot;)
        {
            // Play sound effect
        }
        else if (eventName == &quot;hitFrame&quot;)
        {
            // Enable hitbox
        }
    }
    
    void OnDestroy()
    {
        // Unsubscribe from events
        if (animController != null)
        {
            animController.AnimationEvent -= OnAnimationEvent;
        }
    }
}
</code></pre><h3 id="pattern-2-standalone-animation-effects-ui">Pattern 2: Standalone Animation (Effects, UI)</h3><p>For animations that aren’t tied to entities (visual effects, UI elements):</p><ol><li>Enable <code>_autoTickInUpdate</code> in the inspector (or via code)</li><li>The animation will automatically tick in <code>Update()</code></li></ol><pre><code class="language-csharp">public class EffectAnimation : MonoBehaviour
{
    private SpriteResolverAnimationController animController;
    
    void Start()
    {
        animController = GetComponent&lt;SpriteResolverAnimationController&gt;();
        animController.SetState(&quot;Explosion&quot;);
        
        // Enable auto-tick for standalone animations
        // (or set in inspector)
    }
    
    // AnimationController.Update() handles ticking automatically
    // SpriteResolverAnimationController.LateUpdate() handles sprite updates
}
</code></pre><h3 id="pattern-3-responding-to-animation-events">Pattern 3: Responding to Animation Events</h3><p>Subscribe to <code>AnimationEvent</code> to handle events defined in your DSL:</p><pre><code class="language-csharp">void Start()
{
    animController.AnimationEvent += OnAnimationEvent;
}

void OnAnimationEvent(string eventName)
{
    switch (eventName)
    {
        case &quot;swingSound&quot;:
            audioSource.PlayOneShot(swingClip);
            break;
            
        case &quot;hitFrame&quot;:
            EnableHitbox();
            break;
            
        case &quot;hitOff&quot;:
            DisableHitbox();
            break;
            
        case &quot;vfxJump&quot;:
            Instantiate(jumpVfx, transform.position, Quaternion.identity);
            break;
            
        case &quot;_loop&quot;:
            // Animation looped (if you need to track this)
            break;
    }
}
</code></pre><h3 id="pattern-4-slow-motion--speed-control">Pattern 4: Slow Motion / Speed Control</h3><p>Use <code>DurationMultiplier</code> to control animation speed:</p><pre><code class="language-csharp">// Slow motion (half speed)
animController.DurationMultiplier = 2.0f;

// Fast forward (double speed)
animController.DurationMultiplier = 0.5f;

// Normal speed
animController.DurationMultiplier = 1.0f;
</code></pre><h3 id="pattern-5-state-based-animation-selection">Pattern 5: State-Based Animation Selection</h3><p>Use your game logic to select animation states:</p><pre><code class="language-csharp">void UpdateAnimation()
{
    if (isGrounded)
    {
        if (isMoving)
        {
            animController.SetState(&quot;Run&quot;);
        }
        else
        {
            animController.SetState(&quot;Idle&quot;);
        }
    }
    else
    {
        animController.SetState(&quot;Jump&quot;);
    }
}
</code></pre><h2 id="creating-custom-animation-controllers">Creating Custom Animation Controllers</h2><p>You can extend <code>AnimationController</code> to create custom visual update systems. Here’s how <code>SpriteResolverAnimationController</code> does it:</p><pre><code class="language-csharp">using UnityEngine;
using UnityEngine.U2D.Animation;
using PhantomCompass.Animation;

public class SpriteResolverAnimationController : AnimationController
{
    public SpriteResolver SpriteResolver;

    void OnValidate()
    {
        if (SpriteResolver == null)
        {
            SpriteResolver = GetComponentInChildren&lt;SpriteResolver&gt;();
        }
    }

    void Awake()
    {
        if (SpriteResolver == null)
        {
            SpriteResolver = GetComponentInChildren&lt;SpriteResolver&gt;();
        }
    }

    void LateUpdate()
    {
        // Check if we&#39;re on a new frame
        if (_isNewFrame &amp;&amp; _currentStateData != null)
        {
            // Update sprite visuals
            // _currentStateData.stateName gives the sprite category
            // _currentFrameData.frameIndex gives the sprite frame
            SpriteResolver.SetCategoryAndLabel(
                _currentStateData.stateName, 
                _currentFrameData.frameIndex.ToString()
            );
            
            // Clear the flag after updating
            ClearNewFrameFlag();
        }
    }
}
</code></pre><p><strong>Key points for custom controllers:</strong></p><ol><li><strong>Check <code>_isNewFrame</code></strong> - Only update visuals when this is true</li><li><strong>Use <code>_currentStateData.stateName</code></strong> - This handles sprite category aliases automatically</li><li><strong>Use <code>_currentFrameData.frameIndex</code></strong> - The sprite frame index to display</li><li><strong>Call <code>ClearNewFrameFlag()</code></strong> - After updating visuals, clear the flag</li><li><strong>Update in <code>LateUpdate()</code></strong> - Ensures visuals update after all logic updates</li></ol><h3 id="example-custom-spriterenderer-controller">Example: Custom SpriteRenderer Controller</h3><pre><code class="language-csharp">public class SpriteRendererAnimationController : AnimationController
{
    public SpriteRenderer spriteRenderer;
    public Sprite[] sprites; // Array of sprites for each frame
    
    void LateUpdate()
    {
        if (_isNewFrame &amp;&amp; _currentStateData != null)
        {
            int frameIndex = _currentFrameData.frameIndex;
            if (frameIndex &gt;= 0 &amp;&amp; frameIndex &lt; sprites.Length)
            {
                spriteRenderer.sprite = sprites[frameIndex];
            }
            ClearNewFrameFlag();
        }
    }
}
</code></pre><h2 id="integration-with-entity-system">Integration with Entity System</h2><p>The animation controller is designed to work with entity-based game systems:</p><ol><li><strong>Entity calls <code>Tick()</code></strong> - From <code>Entity.Tick()</code> at fixed rate</li><li><strong>Entity calls <code>SetState()</code></strong> - When state changes (e.g., from FSM)</li><li><strong>Entity subscribes to <code>AnimationEvent</code></strong> - To handle animation events</li><li><strong>EntityReference pattern</strong> - Centralizes component references</li></ol><p>See <code>Entity.cs</code> and <code>EntityReference.cs</code> for a complete example.</p><h2 id="best-practices">Best Practices</h2><ol><li><strong>Always call <code>Tick()</code></strong> - Don’t forget to tick the animation controller each frame</li><li><strong>Use fixed-rate systems</strong> - Call <code>Tick()</code> from fixed-rate systems (not variable <code>Update()</code>)</li><li><strong>Subscribe to events</strong> - Use <code>AnimationEvent</code> for sound effects, hitboxes, VFX</li><li><strong>Set default state</strong> - Always set a <code>DefaultState</code> so animations start correctly</li><li><strong>Check state exists</strong> - Validate state names before calling <code>SetState()</code> (if needed)</li><li><strong>Unsubscribe from events</strong> - Always unsubscribe in <code>OnDestroy()</code> or <code>OnDisable()</code></li><li><strong>Use sprite aliases</strong> - Use <code>StateName[Alias]</code> syntax to reuse sprite sets across states</li></ol><h2 id="troubleshooting">Troubleshooting</h2><h3 id="animation-doesnt-play">Animation doesn’t play</h3><ul><li>Check that <code>Tick()</code> is being called</li><li>Verify the state name matches your DSL (case-sensitive)</li><li>Ensure <code>DefaultState</code> is set if no state is manually set</li></ul><h3 id="sprites-dont-update">Sprites don’t update</h3><ul><li>Verify <code>SpriteResolver</code> component exists</li><li>Check that <code>_isNewFrame</code> is being checked in <code>LateUpdate()</code></li><li>Ensure <code>ClearNewFrameFlag()</code> is called after updating visuals</li></ul><h3 id="events-dont-fire">Events don’t fire</h3><ul><li>Verify you’ve subscribed to <code>AnimationEvent</code></li><li>Check event names match your DSL exactly (case-sensitive)</li><li>Ensure <code>Tick()</code> is being called</li></ul><h3 id="animation-plays-too-fastslow">Animation plays too fast/slow</h3><ul><li>Adjust <code>DurationMultiplier</code> property</li><li>Check frame durations in your DSL</li></ul><h3 id="state-transitions-dont-work">State transitions don’t work</h3><ul><li>Verify target state exists in your DSL</li><li>Check state name spelling (case-sensitive)</li><li>Ensure state has explicit end behavior in DSL</li></ul><h2 id="see-also">See Also</h2><ul><li><code>AnimationController.cs</code> - Base class implementation</li><li><code>SpriteResolverAnimationController.cs</code> - Example implementation</li><li><code>Entity.cs</code> - Example integration with game entities</li></ul></div></article></main><footer class="footer"><div class="wrapper"><div class="footer__copyright"><p>Copyright Jos Yule 2025</p></div><button id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://dev.lofinet.org/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://dev.lofinet.org/assets/js/scripts.min.js?v=ffcbea6c02c8178d10092962b235a5b0"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>